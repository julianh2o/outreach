// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

model Contact {
  id                     String    @id @default(cuid())
  firstName              String
  lastName               String?
  birthday               DateTime?
  notes                  String?
  outreachFrequencyDays  Int?
  preferredContactMethod String? // References ChannelType.id
  lastContacted          DateTime?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  channels          Channel[]
  tags              TagOnContact[]
  customFields      CustomFieldValue[]
  processingBatches MessageProcessingBatch[]
  suggestedUpdates  SuggestedUpdate[]
}

// Channel types: phone, email, address, discord, instagram, facebook_messenger
model Channel {
  id         String  @id @default(cuid())
  type       String // References ChannelType.id
  identifier String // Phone number, email, screen name, handle, etc.
  label      String? // e.g., "Work", "Personal", "Home"
  isPrimary  Boolean @default(false)
  contactId  String
  contact    Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  // For address-type channels, store structured address data
  street1 String?
  street2 String?
  city    String?
  state   String?
  zip     String?
  country String?
}

model ChannelType {
  id          String  @id
  name        String
  description String?
  sortOrder   Int     @default(0)
}

model Tag {
  id       String         @id @default(cuid())
  name     String         @unique
  contacts TagOnContact[]
}

model TagOnContact {
  contactId String
  tagId     String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([contactId, tagId])
}

model CustomFieldDefinition {
  id          String             @id
  name        String
  description String?
  sortOrder   Int                @default(0)
  createdAt   DateTime           @default(now())
  values      CustomFieldValue[]
}

model CustomFieldValue {
  id        String                @id @default(cuid())
  value     String
  contactId String
  fieldId   String
  contact   Contact               @relation(fields: [contactId], references: [id], onDelete: Cascade)
  field     CustomFieldDefinition @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt

  @@unique([contactId, fieldId])
}

// Message Analysis Tables

enum BatchStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum SuggestionStatus {
  PENDING
  ACCEPTED
  REJECTED
  PARTIALLY_ACCEPTED
}

model MessageProcessingBatch {
  id                  String      @id @default(cuid())
  contactId           String
  contact             Contact     @relation(fields: [contactId], references: [id], onDelete: Cascade)
  messageHashes       String // JSON array of message hashes included in batch
  conversationSnippet String // The concatenated messages sent to LLM
  status              BatchStatus @default(PENDING)
  llmPrompt           String? // The full prompt sent to the LLM
  llmResponse         String? // The raw response from the LLM
  errorMessage        String? // Error message if processing failed
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  suggestedUpdates  SuggestedUpdate[]
  processedMessages ProcessedMessage[]
}

model SuggestedUpdate {
  id                String                 @id @default(cuid())
  batchId           String
  batch             MessageProcessingBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  contactId         String
  contact           Contact                @relation(fields: [contactId], references: [id], onDelete: Cascade)
  suggestedChanges  String // JSON - map of field names to suggested values with confidence
  hasNotableUpdates Boolean                @default(false)
  status            SuggestionStatus       @default(PENDING)
  acceptedChanges   String? // JSON - which changes were accepted, null until reviewed
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
}

model ProcessedMessage {
  id          String                 @id @default(cuid())
  messageHash String                 @unique
  batchId     String
  batch       MessageProcessingBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  createdAt   DateTime               @default(now())
}

// Message Sync Tables

model StoredMessage {
  id             String    @id @default(cuid())
  rowid          Int       @unique // From chat.db, used for sync cursor
  guid           String    @unique // Apple's message GUID
  text           String?
  handleId       String // Phone/email identifier
  isFromMe       Boolean
  date           DateTime
  dateRead       DateTime?
  dateDelivered  DateTime?
  chatId         Int?
  hasAttachments Boolean   @default(false)
  createdAt      DateTime  @default(now())

  attachments StoredAttachment[]

  @@index([handleId])
  @@index([date])
  @@index([rowid])
}

model StoredAttachment {
  id           String        @id @default(cuid())
  rowid        Int
  guid         String        @unique
  filename     String?
  mimeType     String?
  transferName String?
  totalBytes   Int           @default(0)
  createdAt    DateTime?
  localPath    String? // Path under data/attachments/ (null if sync failed)
  errorReason  String? // file_not_found, file_too_large, read_error, etc.
  errorDetails String? // Additional error info
  messageId    String
  message      StoredMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([errorReason])
}

model SyncState {
  id              String    @id @default("messages_sync")
  lastSyncedRowid Int       @default(0)
  lastSyncedAt    DateTime?
  updatedAt       DateTime  @updatedAt
}
